{"meta":{"title":"Yemaster's Blog","subtitle":"技术萌新，边学边写","description":"分享学习中遇到的算法、CTF技巧","author":"yemaster","url":"https://blog.yemaster.cn","root":"/"},"pages":[{"title":"","date":"2023-11-11T11:02:09.910Z","updated":"2023-11-09T12:06:06.000Z","comments":true,"path":"404.html","permalink":"https://blog.yemaster.cn/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2023-11-11T14:46:20.000Z","updated":"2023-11-11T15:03:11.954Z","comments":true,"path":"about/index.html","permalink":"https://blog.yemaster.cn/about/","excerpt":"","text":"教育经历 项目经验 代码贡献 HUSTOJ(github 3k star) 贡献前端模板bshark和后台模板bsadmin，受多人好评 开发者 Vety(英语听力播放软件 编写100%代码，适用于高考英语听力自动分材料播放。 开发者 Queshin(简单联机冲击麻将游戏+AI算法) 知识技能 Web开发 前端开发 HTML/CSS/JavaScript 能手搓小型页面 Vue 2/3+axios 能写大型项目 bootstrap 4/5+fo(se)mantic-ui 常用，其他UI也能看文档写 手搓界面不算太差 后端开发 Python3 常用flask/django/fastapi，看文档都能写 Nodejs 常用express/fastify，看文档都能写 PHP 差不多可以 数据库 MySQL可以，能有图形化界面就更好了 软件开发 Electron/NeutralinoJS，果然还是web好写 PySide6，只会照着文档抄，而且不会写好看界面 算法竞赛 C/C++，划水摆烂选手 Pascal，？？？"},{"title":"所有标签","date":"2023-11-12T01:16:43.667Z","updated":"2023-11-09T12:06:06.000Z","comments":true,"path":"blog/tags/index.html","permalink":"https://blog.yemaster.cn/blog/tags/","excerpt":"","text":""},{"title":"文章分类","date":"2023-11-12T01:16:43.667Z","updated":"2023-11-09T12:06:06.000Z","comments":true,"path":"blog/categories/index.html","permalink":"https://blog.yemaster.cn/blog/categories/","excerpt":"","text":""}],"posts":[{"title":"冲击麻将胡牌算法","slug":"agari-algorithm","date":"2023-11-25T14:20:59.000Z","updated":"2023-11-25T15:27:56.405Z","comments":true,"path":"agari-algorithm/","permalink":"https://blog.yemaster.cn/agari-algorithm/","excerpt":"","text":"冲击麻将是浙江省慈溪、余姚地区特有的麻将玩法。一共有136张牌，分为万牌，筒/饼牌，条/索牌，字牌/风头牌，不包括花牌。 胡法可以分为以下三类： 碎胡/大乱/十三不搭 即任意两张同种牌差距大于等于3，并且没有对子。(例如1条4条可以，但是3筒5筒不行)。 七对子 即牌中有7个对子 顺胡 即牌可以分成1个对子，若干个刻子(3张一样的牌)/顺子(3张相连的牌)。 另外，游戏中还加入了“龙/财神/百搭”牌。即该种牌可以代替任何一种牌。 接下来，分别实现每种胡法的算法。用0—8表示一万—九万，9—17表示一筒—九筒，18—26表示一条—九条，27—33表示东南西北中发白。用一个数组表示手牌，dragon变量表示龙。 碎胡的胡牌算法 首先统计每张牌的个数，如果有大于1说明有对子，不能胡。然后看万筒条中有没有差小于3的即可。 function isAgari(paiArr, dragon) &#123; let cardsCount = []; for (let i = 0; i &lt; 34; ++i) cardsCount.push(0); for (let i = 0; i &lt; paiArr.length; ++i) if (paiArr[i] != dragon) // 不必统计龙 cardsCount[paiArr[i]]++; let pai = []; // 给牌排好序 for (let i = 0; i &lt; 34; ++i) for (let j = 0; j &lt; cardsCount[i]; ++j) pai.push(i); for (let i = 1; i &lt; pai.length; ++i) &#123; // 有相邻或间隔为1的万筒条，不能胡 if (Math.abs(pai[i] - pai[i - 1]) &lt;= 2 &amp;&amp; Math.floor(pai[i] / 9) == Math.floor(pai[i - 1] / 9) &amp;&amp; pai[i] &lt; 27) return false; &#125; return true;&#125; 七对子的胡牌算法 这个更简单，只需要统计对子个数就好了，龙特殊处理一下就好了。 function isAgari(paiArr, dragon) &#123; let cardsCount = [], longCount = 0; for (let i = 0; i &lt; 34; ++i) cardsCount.push(0); for (let i = 0; i &lt; paiArr.length; ++i) if (paiArr[i] != dragon) // 不必统计龙 cardsCount[paiArr[i]]++; else longCount++; let pairCount = 0, singleCount = 0; // 分别计算对子数和但张牌个数 for (let i = 0; i &lt; cardsCount.length; ++i) &#123; pairCount += Math.floor(cardsCount[i] / 2); singleCount += cardsCount[i] % 2; &#125; if (singleCount &lt;= longCount) // 龙把单个牌配成对后还有的多，两张龙也能成对 pairCount += singleCount + Math.floor((longCount - singleCount) / 2); else // 把所有龙都把单张牌配对。 pairCount += longCount; if (pairCount &gt;= 7) return true return false;&#125; 顺胡的胡牌算法 如果没有龙，那么这个将是非常简单的。我们只要枚举对子，然后一次判断剩下牌是否为刻字与顺子的组合，只需一个dfs就可以了。但是，有龙的存在，如果我们枚举龙所对应的牌，效率将会非常低下。 因此，我们考虑换个思路。首先，万、筒、条、字牌是分别独立的。我们只需要分别考虑每一块牌是否可胡就行了。这样就分解成了4个子问题。并且这4个子问题规模不大，而且都有重复性，可以暴力枚举。为了优化时间效率，我们还可以把所有可以胡的牌型处理出来，然后只需要枚举龙的分配和对子的位置即可。 比如对于牌：[0,0,0,1,2,5,5,5,10,11,12,27,27,27]。那么我们先拆成 [0,0,0,1,2,5,5,5]、[10,11,12]、[]、[27,27,27] 四部分。然后分别判断每个部分是否可胡。不难发现，对子在第一部分的时候就是都可胡的。我们只需要枚举每部分分别在有无对子、有 nnn 条龙的情况下是否可胡即可，而这数据量不大，完全可以先爆搜预处理，然后查表。 表的生成 #include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int cnt[10];int q[10];// Array(8)，有对子/无对子+龙0123inline bool check(int z)&#123; if (z &gt;= 10) return true; if (q[z] &gt; 0) &#123; bool flag; if (z + 2 &lt;= 9 &amp;&amp; q[z + 1] &gt; 0 &amp;&amp; q[z + 2] &gt; 0) // 可以抽顺子，枚举抽顺子 &#123; q[z] -= 1; q[z + 1] -= 1; q[z + 2] -= 1; flag = check(z); q[z] += 1; q[z + 1] += 1; q[z + 2] += 1; if (flag) return true; &#125; if (q[z] &gt;= 3) // 可以抽刻字，枚举抽刻字 &#123; q[z] -= 3; flag = check(z); q[z] += 3; if (flag) return true; &#125; return false; &#125; else return check(z + 1);&#125;inline bool check_dz(bool dz, int sum)&#123; if (dz) &#123; for (int i = 1; i &lt;= 9; ++i) // 枚举哪张牌作为对子 &#123; if (q[i] &lt; 2) continue; q[i] -= 2; bool flag = check(1); q[i] += 2; if (flag) return true; &#125; &#125; else &#123; if (check(1)) return true; &#125; return false;&#125;inline bool check_dragon(bool dz, int dragon, int sum)&#123; if (dragon + sum &gt; 14) return false; if (dragon &gt; 0) &#123; for (int i = 1; i &lt;= 9; ++i) // 枚举龙所对应的牌 if (q[i] &lt; 4) &#123; q[i] += 1; bool flag = check_dragon(dz, dragon - 1, sum); q[i] -= 1; if (flag) return true; &#125; return false; &#125; else &#123; return check_dz(dz, sum); &#125;&#125;inline void dfs(int u, int sum) // 先枚举出所有牌型。用9个数字表示9种牌的个数。&#123; if (u &gt; 9) &#123; if (sum) putchar(&#x27;,&#x27;); putchar(&#x27;&quot;&#x27;); for (int i = 1; i &lt;= 9; ++i) putchar(&#x27;0&#x27; + cnt[i]); putchar(&#x27;&quot;&#x27;); putchar(&#x27;:&#x27;); putchar(&#x27;[&#x27;); for (int j = 0; j &lt; 8; ++j) // j=0~3表示有对子，j条龙；4~7表示无对子，j-5条龙. &#123; for (int i = 1; i &lt;= 9; ++i) q[i] = cnt[i]; if (check_dragon(j &lt;= 3, j % 4, sum)) printf(&quot;true&quot;); else printf(&quot;false&quot;); if (j &lt; 7) putchar(&#x27;,&#x27;); &#125; putchar(&#x27;]&#x27;); // exit(0); return; &#125; for (int i = 0; i &lt;= 4; ++i) &#123; if (sum + i &lt;= 14) &#123; cnt[u] = i; dfs(u + 1, sum + i); &#125; &#125;&#125;int main()&#123; freopen(&quot;data.js&quot;, &quot;w&quot;, stdout); // 输出为js文件，方便js调用。 putchar(&#x27;h&#x27;); putchar(&#x27;=&#x27;); putchar(&#x27;&#123;&#x27;); dfs(1, 0); putchar(&#x27;&#125;&#x27;); putchar(&#x27;\\n&#x27;); printf(&quot;module.exports=&#123;h&#125;&quot;); return 0;&#125; 上面是数字牌的情况，字牌也是类似的。不过我这里为了方便，字牌用了另一种记录方法，记录有4张、3张、2张、1张、0张的字牌分别由几种。因为字牌不能组成顺子，所以只需要判断刻字和对子即可。 inline void dfs(int u, int sum, int sum2)&#123; if (u &gt; 4) &#123; if (tot) putchar(&#x27;,&#x27;); tot++; putchar(&#x27;&quot;&#x27;); for (int i = 0; i &lt;= 4; ++i) putchar(&#x27;0&#x27; + cnt[i]); putchar(&#x27;&quot;&#x27;); putchar(&#x27;:&#x27;); putchar(&#x27;[&#x27;); for (int i = 0; i &lt;= 1; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; if (i + j) putchar(&#x27;,&#x27;); if (cnt[4] &gt; 0) printf(&quot;false&quot;); else &#123; int need = 2 * cnt[1] + 1 * cnt[2]; if (i == 0) &#123; need -= 1; if (need &lt; 0) need += 3; &#125; if (need == j || need + 3 == j) printf(&quot;true&quot;); else printf(&quot;false&quot;); &#125; &#125; &#125; putchar(&#x27;]&#x27;); &#125; else &#123; for (int i = 0; i &lt;= 7; ++i) if (sum + i * u &lt;= 14 &amp;&amp; sum2 + i &lt;= 7) &#123; cnt[u] = i; dfs(u + 1, sum + i * u, sum2 + i); &#125; &#125;&#125; 胡牌检验 有了上面两个文件生成的数据，然后就可以判断了。 const distributeLong = [[[0, 0, 0, 0]],[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]],[[2, 0, 0, 0], [0, 2, 0, 0], [0, 0, 2, 0], [0, 0, 0, 2], [1, 1, 0, 0], [1, 0, 1, 0], [1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 0, 1], [0, 0, 1, 1]],[[3, 0, 0, 0], [0, 3, 0, 0], [0, 0, 3, 0], [0, 0, 0, 3], [1, 2, 0, 0], [1, 0, 2, 0], [1, 0, 0, 2], [2, 1, 0, 0], [0, 1, 2, 0], [0, 1, 0, 2], [2, 0, 1, 0], [0, 2, 1, 0], [0, 0, 1, 2], [2, 0, 0, 1], [0, 2, 0, 1], [0, 0, 2, 1], [1, 1, 1, 0], [1, 1, 0, 1], [1, 0, 1, 1], [0, 1, 1, 1]]]function isAgari(paiArr, dragon) &#123; let cardsCount = [], longCount = 0; for (let i = 0; i &lt; 34; ++i) cardsCount.push(0); for (let i = 0; i &lt; paiArr.length; ++i) if (paiArr[i] != dragon) // 不必统计龙 cardsCount[paiArr[i]]++; else longCount++; let paiStr = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;] // 计算四部分的牌型 let fengCount = [0, 0, 0, 0, 0] for (let i = 0; i &lt; 3; ++i) for (let j = 0; j &lt; 9; ++j) paiStr[i] += cardsCount[i * 9 + j] for (let i = 27; i &lt; 34; ++i) &#123; fengCount[cardsCount[i]]++ &#125; for (let i = 0; i &lt;= 4; ++i) paiStr[3] += fengCount[i] for (let i = 0; i &lt; 4; ++i) &#123; for (let j in distributeLong[longCount]) &#123; // 枚举4个部分龙的个数 flag = true; try &#123; for (let k = 0; k &lt; 4; ++k) &#123; // k枚举对子的位置 if (k &lt;= 2 &amp;&amp; !h[paiStr[k]][(i != k) * 4 + distributeLong[longCount][j][k]]) &#123; flag = false; break; &#125; if (k == 3 &amp;&amp; !p[paiStr[k]][(i != k) * 4 + distributeLong[longCount][j][k]]) &#123; flag = false; break; &#125; &#125; &#125; catch (e) &#123; flag = false &#125; if (flag) return true; &#125; &#125; return false;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yemaster.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://blog.yemaster.cn/tags/%E6%B8%B8%E6%88%8F/"},{"name":"麻将","slug":"麻将","permalink":"https://blog.yemaster.cn/tags/%E9%BA%BB%E5%B0%86/"}],"author":"yemaster"},{"title":"Miller Rabin算法","slug":"miller-rabin","date":"2023-11-11T11:13:36.000Z","updated":"2023-11-12T01:26:32.121Z","comments":true,"path":"miller-rabin/","permalink":"https://blog.yemaster.cn/miller-rabin/","excerpt":"","text":"费马素性检验 由费马小定理，如果 ppp 为质数并且 (a,p)=1\\left(a,p\\right)=1(a,p)=1，那么 ap−1≡1(mod p)a^{p-1}\\equiv 1 \\left(\\text{mod}\\ p\\right)ap−1≡1(mod p)。那么，如果 ap−1≢1(mod p)a^{p-1}\\not\\equiv 1 \\left(\\text{mod}\\ p\\right)ap−1≡1(mod p)，那么 ppp 就一定不是素数。因此，我们只要多试几个数，如果 ap−1≡1(mod p)a^{p-1}\\equiv 1 \\left(\\text{mod}\\ p\\right)ap−1≡1(mod p) 都成立，那么 ppp 大概率就是素数。 但仍旧存在极少的一些合数，即便遍历 [2,p−1]\\left[2,p-1\\right][2,p−1] 的每一个数字作为底数，也无法筛去。这样的合数被称为卡迈克尔数，在一亿内有 255255255 个，最小的卡迈克尔数为 561561561。若 nnn 为卡迈克尔数，则 2n−12^n-12n−1 也是卡迈克尔数，故其个数是无穷的。 因此，我们要考虑其他的方法。 二次探测 如果 ppp 为质数，那么方程 x2≡1(modp)x^2\\equiv 1\\left(\\text{mod} p\\right)x2≡1(modp) 只有 2 个解(x1=1,x2=p−1x_1=1,x_2=p-1x1​=1,x2​=p−1)。 证明：因为 ppp 为质数，又 p∣(x−1)(x+1)p|(x-1)(x+1)p∣(x−1)(x+1)，则 p∣x−1p|x-1p∣x−1 或 p∣x+1p|x+1p∣x+1，所以 x=1x=1x=1 或 x=p−1x=p-1x=p−1。 这样子，事先判定掉偶数的情况。ppp 为奇数时，ap−1=(ap−12)2≡1(modp)a^{p-1}=\\left(a^\\frac{p-1}{2}\\right)^2\\equiv 1\\left(\\text{mod} p\\right)ap−1=(a2p−1​)2≡1(modp)。因此，我们可以通过判断 ap−12a^\\frac{p-1}{2}a2p−1​ 是否是 111 和 p−1p-1p−1 中的一个来判断 ppp 是否为质数。同样的，这只是必要条件。我们可以通过多次判断来降低错误概率。 代码 C++代码 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define RI register intusing namespace std;int prime[21]= &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 79&#125;;inline int Quick_Multiply(int a, int b, int c) &#123; long long ans = 0, res = a; while (b) &#123; if (b &amp; 1) ans = (ans + res) % c; res = (res + res) % c; b &gt;&gt;= 1; &#125; return (int)ans;&#125;int Quick_Power(int a, int b, int c) &#123; int ans= 1, res = a; while (b) &#123; if(b &amp; 1) ans = Quick_Multiply(ans, res, c); res = Quick_Multiply(res, res, c); b &gt;&gt;= 1; &#125; return ans;&#125;bool Miller_Rabin(int x) &#123; int s = 0, t = x - 1, k; if (x==2) return 1; if (x &lt; 2 || !(x &amp; 1)) return 0; while(!(t &amp; 1)) &#123; s++; t &gt;&gt;= 1; &#125; for(RI i = 0; i &lt; 1 &amp;&amp; prime[i] &lt; x; ++i) &#123; int a = prime[i]; int b = Quick_Power(a, t, x); for(RI j = 1; j &lt;= s; ++j) &#123; k = Quick_Multiply(b, b, x); if (k == 1 &amp;&amp; b != 1 &amp;&amp; b != x - 1) return 0; b = k; &#125; if(b != 1) return 0; &#125; return 1;&#125;int main() &#123; int x; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); while (m--) &#123; scanf(&quot;%d&quot;, &amp;x); if(Miller_Rabin(x)) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yemaster.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://blog.yemaster.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"素数","slug":"素数","permalink":"https://blog.yemaster.cn/tags/%E7%B4%A0%E6%95%B0/"}],"author":"yemaster"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yemaster.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://blog.yemaster.cn/tags/%E6%B8%B8%E6%88%8F/"},{"name":"麻将","slug":"麻将","permalink":"https://blog.yemaster.cn/tags/%E9%BA%BB%E5%B0%86/"},{"name":"数论","slug":"数论","permalink":"https://blog.yemaster.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"素数","slug":"素数","permalink":"https://blog.yemaster.cn/tags/%E7%B4%A0%E6%95%B0/"}]}