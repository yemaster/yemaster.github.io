{"meta":{"title":"Yemaster's Blog","subtitle":"技术萌新，边学边写","description":"Volantis 是一个功能丰富、高度模块化的 Hexo 博客主题。得益于其强大的模块化特性，您可以轻松搭建一个极简风格的博客，也可以仿照官网搭建一个多人协作的、包含文档模块的大体量综合型博客。","author":"yemaster","url":"http://yemaster.oigat.cn","root":"/"},"pages":[{"title":"","date":"2023-11-11T11:02:09.910Z","updated":"2023-11-09T12:06:06.000Z","comments":true,"path":"404.html","permalink":"http://yemaster.oigat.cn/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2023-11-11T14:46:20.000Z","updated":"2023-11-11T15:03:11.954Z","comments":true,"path":"about/index.html","permalink":"http://yemaster.oigat.cn/about/","excerpt":"","text":"教育经历 项目经验 代码贡献 HUSTOJ(github 3k star) 贡献前端模板bshark和后台模板bsadmin，受多人好评 开发者 Vety(英语听力播放软件 编写100%代码，适用于高考英语听力自动分材料播放。 开发者 Queshin(简单联机冲击麻将游戏+AI算法) 知识技能 Web开发 前端开发 HTML/CSS/JavaScript 能手搓小型页面 Vue 2/3+axios 能写大型项目 bootstrap 4/5+fo(se)mantic-ui 常用，其他UI也能看文档写 手搓界面不算太差 后端开发 Python3 常用flask/django/fastapi，看文档都能写 Nodejs 常用express/fastify，看文档都能写 PHP 差不多可以 数据库 MySQL可以，能有图形化界面就更好了 软件开发 Electron/NeutralinoJS，果然还是web好写 PySide6，只会照着文档抄，而且不会写好看界面 算法竞赛 C/C++，划水摆烂选手 Pascal，？？？"}],"posts":[{"title":"Miller Rabin算法","slug":"miller-rabin","date":"2023-11-11T11:13:36.000Z","updated":"2023-11-11T15:30:46.048Z","comments":true,"path":"miller-rabin/","permalink":"http://yemaster.oigat.cn/miller-rabin/","excerpt":"","text":"费马素性检验 由费马小定理，如果 ppp 为质数并且 (a,p)=1\\left(a,p\\right)=1(a,p)=1，那么 ap−1≡1(mod p)a^{p-1}\\equiv 1 \\left(\\text{mod}\\ p\\right)ap−1≡1(mod p)。那么，如果 ap−1≢1(mod p)a^{p-1}\\not\\equiv 1 \\left(\\text{mod}\\ p\\right)ap−1≡1(mod p)，那么 ppp 就一定不是素数。因此，我们只要多试几个数，如果 ap−1≡1(mod p)a^{p-1}\\equiv 1 \\left(\\text{mod}\\ p\\right)ap−1≡1(mod p) 都成立，那么 ppp 大概率就是素数。 但仍旧存在极少的一些合数，即便遍历 [2,p−1]\\left[2,p-1\\right][2,p−1] 的每一个数字作为底数，也无法筛去。这样的合数被称为卡迈克尔数，在一亿内有 255255255 个，最小的卡迈克尔数为 561561561。若 nnn 为卡迈克尔数，则 2n−12^n-12n−1 也是卡迈克尔数，故其个数是无穷的。 因此，我们要考虑其他的方法。 二次探测 如果 ppp 为质数，那么方程 x2≡1(modp)x^2\\equiv 1\\left(\\text{mod} p\\right)x2≡1(modp) 只有 2 个解(x1=1,x2=p−1x_1=1,x_2=p-1x1​=1,x2​=p−1)。 证明：因为 ppp 为质数，又 p∣(x−1)(x+1)p|(x-1)(x+1)p∣(x−1)(x+1)，则 p∣x−1p|x-1p∣x−1 或 p∣x+1p|x+1p∣x+1，所以 x=1x=1x=1 或 x=p−1x=p-1x=p−1。 这样子，事先判定掉偶数的情况。ppp 为奇数时，ap−1=(ap−12)2≡1(modp)a^{p-1}=\\left(a^\\frac{p-1}{2}\\right)^2\\equiv 1\\left(\\text{mod} p\\right)ap−1=(a2p−1​)2≡1(modp)。因此，我们可以通过判断 ap−12a^\\frac{p-1}{2}a2p−1​ 是否是 111 和 p−1p-1p−1 中的一个来判断 ppp 是否为质数。同样的，这只是必要条件。我们可以通过多次判断来降低错误概率。 代码 C++代码 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define RI register intusing namespace std;int prime[21]= &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 79&#125;;inline int Quick_Multiply(int a, int b, int c) &#123; long long ans = 0, res = a; while (b) &#123; if (b &amp; 1) ans = (ans + res) % c; res = (res + res) % c; b &gt;&gt;= 1; &#125; return (int)ans;&#125;int Quick_Power(int a, int b, int c) &#123; int ans= 1, res = a; while (b) &#123; if(b &amp; 1) ans = Quick_Multiply(ans, res, c); res = Quick_Multiply(res, res, c); b &gt;&gt;= 1; &#125; return ans;&#125;bool Miller_Rabin(int x) &#123; int s = 0, t = x - 1, k; if (x==2) return 1; if (x &lt; 2 || !(x &amp; 1)) return 0; while(!(t &amp; 1)) &#123; s++; t &gt;&gt;= 1; &#125; for(RI i = 0; i &lt; 1 &amp;&amp; prime[i] &lt; x; ++i) &#123; int a = prime[i]; int b = Quick_Power(a, t, x); for(RI j = 1; j &lt;= s; ++j) &#123; k = Quick_Multiply(b, b, x); if (k == 1 &amp;&amp; b != 1 &amp;&amp; b != x - 1) return 0; b = k; &#125; if(b != 1) return 0; &#125; return 1;&#125;int main() &#123; int x; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); while (m--) &#123; scanf(&quot;%d&quot;, &amp;x); if(Miller_Rabin(x)) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125; return 0;&#125;","categories":[],"tags":[],"author":"yemaster"}],"categories":[],"tags":[]}